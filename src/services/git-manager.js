/**
 * Git Manager Service - Handle git operations for autonomous fixing
 * Manages branches, commits, and safety features for AI-generated fixes
 */

const { exec } = require('child_process')
const { promisify } = require('util')
const path = require('path')
const chalk = require('chalk')
const execAsync = promisify(exec)
const logger = require('../utils/logger')

class GitManager {
  constructor(repoPath) {
    this.repoPath = path.resolve(repoPath)
    this.originalBranch = null
  }
  
  /**
   * Check if directory is a git repository
   */
  async isGitRepo() {
    try {
      await this.execGit('rev-parse --git-dir')
      return true
    } catch (error) {
      return false
    }
  }
  
  /**
   * Check for uncommitted changes
   */
  async hasUncommittedChanges() {
    try {
      const { stdout } = await this.execGit('status --porcelain')
      return stdout.trim().length > 0
    } catch (error) {
      return false
    }
  }
  
  /**
   * Get current branch name
   */
  async getCurrentBranch() {
    try {
      const { stdout } = await this.execGit('rev-parse --abbrev-ref HEAD')
      return stdout.trim()
    } catch (error) {
      throw new Error(`Failed to get current branch: ${error.message}`)
    }
  }
  
  /**
   * Check if branch exists
   */
  async branchExists(branchName) {
    try {
      await this.execGit(`rev-parse --verify ${branchName}`)
      return true
    } catch (error) {
      return false
    }
  }
  
  /**
   * Create new branch for fixes
   */
  async createBranch(branchName) {
    try {
      // Store original branch
      this.originalBranch = await this.getCurrentBranch()
      
      // Create and switch to new branch
      await this.execGit(`checkout -b ${branchName}`)
      
      await logger.info('Created fixing branch', {
        branch: branchName,
        original_branch: this.originalBranch,
        repo_path: this.repoPath
      })
      
      return branchName
      
    } catch (error) {
      throw new Error(`Failed to create branch ${branchName}: ${error.message}`)
    }
  }
  
  /**
   * Delete branch
   */
  async deleteBranch(branchName) {
    try {
      // Switch to original branch first
      if (this.originalBranch) {
        await this.execGit(`checkout ${this.originalBranch}`)
      }
      
      // Force delete the branch
      await this.execGit(`branch -D ${branchName}`)
      
      await logger.info('Deleted branch', { branch: branchName })
      
    } catch (error) {
      throw new Error(`Failed to delete branch ${branchName}: ${error.message}`)
    }
  }
  
  /**
   * Commit changes with detailed message
   */
  async commitChanges(message, fixes = []) {
    try {
      // Add all changed files
      await this.execGit('add .')
      
      // Build comprehensive commit message
      const commitMessage = this.buildCommitMessage(message, fixes)
      
      // Commit with detailed message
      await this.execGit(`commit -m "${commitMessage}"`)
      
      await logger.info('Committed autonomous fixes', {
        fixes_count: fixes.length,
        commit_message: message
      })
      
      return await this.getLatestCommitHash()
      
    } catch (error) {
      throw new Error(`Failed to commit changes: ${error.message}`)
    }
  }
  
  /**
   * Build detailed commit message for autonomous fixes
   */
  buildCommitMessage(baseMessage, fixes = []) {
    if (fixes.length === 0) {
      return baseMessage
    }
    
    const fixSummary = fixes.reduce((acc, fix) => {
      const type = fix.vulnerability_type || 'unknown'
      acc[type] = (acc[type] || 0) + 1
      return acc
    }, {})
    
    const summaryLines = Object.entries(fixSummary)
      .map(([type, count]) => `- ${type}: ${count} fixed`)
      .join('\\n')
    
    return `${baseMessage}

Autonomous fixes applied by Vaultace AI:
${summaryLines}

Total vulnerabilities fixed: ${fixes.length}
AI Model: Claude Sonnet 4
Generated by: Vaultace CLI v1.0.0

Co-authored-by: Vaultace AI <ai@vaultace.com>`
  }
  
  /**
   * Get latest commit hash
   */
  async getLatestCommitHash() {
    try {
      const { stdout } = await this.execGit('rev-parse HEAD')
      return stdout.trim()
    } catch (error) {
      return null
    }
  }
  
  /**
   * Create stash of current changes
   */
  async stashChanges(stashName = 'vaultace-fixes') {
    try {
      await this.execGit(`stash push -m "${stashName}"`)
      await logger.info('Stashed changes', { stash_name: stashName })
    } catch (error) {
      throw new Error(`Failed to stash changes: ${error.message}`)
    }
  }
  
  /**
   * Apply stashed changes
   */
  async applyStash(stashName = 'vaultace-fixes') {
    try {
      await this.execGit('stash pop')
      await logger.info('Applied stashed changes')
    } catch (error) {
      throw new Error(`Failed to apply stash: ${error.message}`)
    }
  }
  
  /**
   * Rollback to original state
   */
  async rollbackToOriginal() {
    try {
      if (this.originalBranch) {
        await this.execGit(`checkout ${this.originalBranch}`)
        await logger.info('Rolled back to original branch', { 
          original_branch: this.originalBranch 
        })
      }
    } catch (error) {
      throw new Error(`Failed to rollback: ${error.message}`)
    }
  }
  
  /**
   * Get diff of changes made
   */
  async getDiff(fromCommit = null) {
    try {
      const command = fromCommit 
        ? `diff ${fromCommit}..HEAD`
        : 'diff --cached'
      
      const { stdout } = await this.execGit(command)
      return stdout
      
    } catch (error) {
      return ''
    }
  }
  
  /**
   * Get list of changed files
   */
  async getChangedFiles() {
    try {
      const { stdout } = await this.execGit('diff --name-only --cached')
      return stdout.trim().split('\n').filter(file => file.length > 0)
    } catch (error) {
      return []
    }
  }
  
  /**
   * Create pull request branch and prepare for PR
   */
  async preparePullRequest(fixes, baseBranch = 'main') {
    try {
      const prTitle = `ðŸ¤– Autonomous security fixes: ${fixes.length} vulnerabilities resolved`
      const prBody = this.buildPullRequestBody(fixes)
      
      await logger.info('Pull request prepared', {
        title: prTitle,
        base_branch: baseBranch,
        fixes_count: fixes.length
      })
      
      return {
        title: prTitle,
        body: prBody,
        head: await this.getCurrentBranch(),
        base: baseBranch
      }
      
    } catch (error) {
      throw new Error(`Failed to prepare pull request: ${error.message}`)
    }
  }
  
  /**
   * Build pull request body with fix details
   */
  buildPullRequestBody(fixes) {
    const appliedFixes = fixes.filter(f => f.status === 'applied')
    const failedFixes = fixes.filter(f => f.status === 'failed')
    
    const severityBreakdown = appliedFixes.reduce((acc, fix) => {
      acc[fix.severity] = (acc[fix.severity] || 0) + 1
      return acc
    }, {})
    
    return `## ðŸ¤– Autonomous Security Fixes by Vaultace AI

### Summary
This PR contains ${appliedFixes.length} autonomous security fixes generated and applied by Vaultace AI using Claude Sonnet 4.

### Vulnerabilities Fixed
${Object.entries(severityBreakdown).map(([severity, count]) => 
    `- **${severity}**: ${count} vulnerabilities`
  ).join('\n')}

### Fixed Issues
${appliedFixes.map((fix, index) => 
    `${index + 1}. **${fix.vulnerability_type}** in \`${path.basename(fix.file_path)}\`\n   - ${fix.description}`
  ).join('\n')}

### AI Model Details
- **Model**: Claude Sonnet 4
- **Confidence Score**: ${(appliedFixes.reduce((acc, f) => acc + f.confidence, 0) / appliedFixes.length).toFixed(2)}
- **Risk Assessment**: Most fixes are low-risk automated changes

### Testing
- [x] All fixes validated by AI before application
- [x] No breaking changes introduced
- [ ] Manual testing recommended for authentication-related fixes

### Rollback Plan
If issues arise, rollback is simple:
\`\`\`bash
git revert <commit-hash>
\`\`\`

---
*Generated by Vaultace CLI v1.0.0 â€¢ [Learn more about autonomous fixing](https://docs.vaultace.com/autonomous-fixing)*`
  }
  
  /**
   * Execute git command in repository directory
   */
  async execGit(command) {
    try {
      return await execAsync(`git ${command}`, { 
        cwd: this.repoPath,
        timeout: 30000 // 30 second timeout
      })
    } catch (error) {
      throw new Error(`Git command failed: ${error.message}`)
    }
  }
}

module.exports = GitManager